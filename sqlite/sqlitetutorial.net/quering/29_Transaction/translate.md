# SQLite TRANSACTION #########################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-transaction/

## Обзор ##############################

В этом руководстве мы покажем вам, как использовать транзакции SQLite для обеспечения целостности и достоверности данных.

## SQLite и ACID

SQLite это транзакционная база данных в которой все изменения и запросы являются атомарными, консистентными, изолироваными и долговечными (ACID).

SQLite гарантирует, что все транзакции соответствуют требованиям ACID даже если транзакция прервана програмным сбоем, сбоем ОС, или прерыванием питания компьютера.

- **A**tomic: транзакции должны быть атомарными. Это означает, что изменения не могут быть разбиты на более мелкие. Когда вы фиксируете транзакцию, каждая конкретная транзакция либо применяется, либо нет.

- **C**onsistent: транзакция должна удостоверится, что изменения базы из одного действующего состояния, переходит в другое действующее состояние. Когда транзакция начинается и выполняет выражение по модификации данных, база становится несогласованной. В то время как, когда транзакция зафиксирована или откачена, важно, чтобы эта транзакция оставляла базу согласованной.

- **I**solation: ожидающая выполнения транзакция сессии должна быть изолирована от остальных сессий. Когда сессия начинает транзакцию и выполняет выражения `INSERT` или `UPDATE` для изменения данных, эти изменения должны быть видны только в текущей сессии, но не в остальных. С другой стороны, изменения, зафиксированные другими сессиями, после начала транзакции, не должны быть видимы в текущей сессии.

- **D**urable: если транзакция успешно зафиксирована, изменения в БД должны быть перманентными, несмотря на состояния, такие как, неисправное питание или програмный сбой. В противном случае, если програмный сбой произошол перед тем, как транзакция была зафиксирована, изменения не должны сохраняться.

## Выражение SQLite `TRANSACTION`

По умолчанию, SQLite работает в режиме авто-фиксации. Это означает, что каждаую команду, SQLite начинает, выполняет, и фиксирует транзакцию автоматически.

Чтобы явно начать транзакцию, используйте следующие шаги:

Первое - откройте транзакцию, используя команду `BEGIN TRANSACTION`.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BEGIN TRANSACTION;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

После выполнения выражения `BEGIN TRANSACTION` транзакция открыта до момента явногй фиксации или отката.

Второе - выполните инструкции SQLite для выбора или обновления вынных в БД. Помните, что эти изменения будут видны только в рамках текущей сессии (или клиента).

Третье - зафиксируйте изменения в БД используя выражения `COMMIT` или `COMMIT TRANSACTION`.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
COMMIT;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если вы не хотите сохранять изменения, то вы можете откатить из используя выражения `ROLLBACK` или `ROLLBACK TRANSACTION`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ROLLBACK;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Примеры транзакций SQLite

Для демонстрации, мы создадим две новые таблицы: `accounts` и `account_changes`.

Таблица `accounts` хранит данные о номерах аккаунтов и их балансе. Таблица `account_changes` хранит изменения аккаунтов.

Первое - создадим таблицы `accounts` и `account_changes` используя следующие выражения `CRATE TABLE`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE accounts (
  account_no INTEGER NOT NULL,
  balance DECIMAL NOT NULL DEFAULT 0,
  PRIMARY KEY (account_no),
  CHECK (balance >= 0)
);

CREATE TABLE account_changes (
  change_no INT NOT NULL PRIMARY KEY,
  account_no INTEGER NOT NULL,
  flag TEXT NOT NULL,
  amount DECIMAL NOT NULL,
  changed_at TEXT NOT NULL
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Второе - вставим пробные значения в таблицу `accounts`.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO accounts (account_no, balance)
VALUES (100, 20100);

INSERT INTO accounts (account_no, balance)
VALUES (200, 10100);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В-третьих - выберем данные из таблицы `accounts`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT * FROM accounts;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В-четвёртых - переместим 1000 из аккаунта 100 в аккаунт 200, и запишем лог изменений в таблицу `account_changes` в одной транзакции.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BEGIN TRANSACTION;

UPDATE accounts
   SET balacne = balance - 1000
 WHERE account_no = 100;

UPDATE accounts
SET balacne = balance + 1000
WHERE account_no = 200;

INSERT INTO account_changes (account_no, flag, amount, changed_at)
VALUES (100, '-', 1000, DATETIME('NOW'));

INSERT INTO account_changes (acocunt_no, flag, amount, changed_at)
VALUES (200, '+', 1000, DATETIME('NOW'));

COMMIT;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как вы можете видеть, балансы были успешно обновлены.

Шестое - выберем данные из таблицы `account_changes`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT * FROM account_changes;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Рассмотрим другой пример, где откатим транзакцию.

1. Попытаемя списать 20000 со счета аккаунта 100:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BEGIN TRANSACTION;

UPDATE accounts
SET balance = balance - 20000
WHERE account_no = 100;

INSERT INTO account_changes (account_no, flag, amount, changed_at)
VALUES (100, '-', 20000, DATETIME('NOW'));
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SQLite сообщит об ошибке нехватки баланса.

Однако, лог будет сохранен в таблицу `account_changes`.

2. Откатим транзакцию используя выражнеие `ROLLBACK`.

3. Выбарем данные.

В этом руководстве вы изучили, как работать с транзакциями SQLite используя `BEGIN TRANSACTION`, `COMMIT`, и `ROLLBAKC` для контроля транзакция в БД SQLite.

---------------------------------------

Предидущее руководство < [SQLite REPLACE][prev]  
Следующее руководство > [SQLite FULL-TEXT SEARCH][next]

[prev]: ../28_Replace/translate.md
[next]: ../30_FullTextSearch/translate.md