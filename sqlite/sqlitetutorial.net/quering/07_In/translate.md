# SQLite IN ######################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-in/

## Обзор ##############################

В этом руководстве вы изучите, как использовать оператор SQLite `IN` чтобы определить, соответствует ли значение какому-либо значению из списка значений или резултате подзапроса.

## Знакомство с оператором SQLite `IN`

Оператор SQLite `IN` определяет, соответствует ли значение какому-либо значению списка или [подзапроса][subquery]. Синтаксис оператора `IN` представлен ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression [NOT] IN (value_list|subquery);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`expression` может быть любым подходящим выражением или столбцом таблицы.

Список значений представляет собой фиксированый список значений или результат возврата единичной колонки подзапроса. Тип возвращаемого значения и значений в списке должны совподать.

Оператор `IN` возвращает `true` или `false` в зависимости от токо, соответствует ли выражение какому-либо занчению в списке значений или нет. Чтобы инвертировать результат вхождения в список значений используется оператор `NOT IN`.

## Примеры использования оператора SQLite `IN`

Для демонстрации, мы будем использовать таблицу `Tracks` из тестовой базы данных.

|   tracks       |
|----------------|
| * Tracked      |
|   Name         |
|   AlbumId      |
|   MediaTypeId  |
|   GenderId     |
|   Composer     |
|   Milliseconds |
|   Bytes        |
|   UnitPrice    |

Следующее выражение использует оператор `IN` чтобы запросить треки, чей id типа равен `1` или `2`.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  trackId,
  name,
  mediatypeId
FROM
  tracks
WHERE
  mediaTypeId IN (1, 2)
ORDER BY
  name ASC;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Этот запрос использует оператор `OR` вместо оператора `IN` для достижения того же результата запроса, приведённого выше:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  trackId,
  name,
  mediaTypeId
FROM
  tracks
WHERE
  mediaTypeId = 1 OR mediaTypeId = 2
ORDER BY
  name ASC;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как вы можете видеть исходя из запросов, использование оператра `IN` намного короче.

Если у вас есть запрос с большим количеством операторов `OR`, вы можете рассмотреть возможность использования вместо этого оператор `IN`, чтобы сделать запрос более читабельным.

## Пример использования оператора SQLite `IN` с подзапросом

Слудующий запрос возвращает список id альбомов у которых id артистов равен `12`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT albumid
FROM albums
WHERE artistid = 12;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтобы получить треки, которые принадлежат артистам по id `12` вы можете скомбинировать оператор `IN` с подзапросом, как показано ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  trackId,
  name,
  albumId
FROM
  tracks
WHERE
  albumId IN (
    SELECT albumId
    FROM albums
    WHERE artistId = 12
  );
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом примере:

- Сначала, подзапрос возвращает список id альбомов, пренадлежащим артисту с id `12`.

- Затем, внешний запрос возаращает терки, чти id альбомов совпадают с каким-либо id из списка, возвращенным подзапросом.

## Пример использования опрератора SQLite `NOT IN`

Следующее выражение возвращает список треков, чьи id жанра не попадают в список (`1`, `2`, `3`).

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  trackid,
  name,
  genreid
FROM
  tracks
WHERE
  genreid NOT IN (1, 2, 3);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом руководстве вы изучили, как использовать оператор SQLite `IN` для сопоставления значения со списком значений или результатом подзапроса.

Предидущее руководство < [SQLite BETWEEN][prev]  
Следующее руководство > [SQLite LIKE][next]

[prev]: ../06_Between/translate.md
[next]: ../08_Like/translate.md

[subquery]: https://www.sqlitetutorial.net/sqlite-subquery/