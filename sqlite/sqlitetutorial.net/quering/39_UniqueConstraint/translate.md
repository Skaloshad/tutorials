# SQLite UNIQUE CONSTRAINT #########################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-unique-constraint/

## Обзор ##############################

В этом руководстве вы изучите, как сипользовать ограничение SQLite `UNIQUE`, чтобы убедиться, что все значения столбца или группы столбцов являются уникальными.

## Знакомство с ограничением SQLite `UNIQUE`

Ограничение SQLite `UNIQUE` гарантирует, что все значения столбца или группы столбцов отличаются друг от друга или являются уникальными.

Для объявления ограничения `UNIQUE` используется ключевое слово, следующее за объявлением столбца.

Вы можете объявить ограничение `UNIQUE` для стобца, или для всей таблицы. Только на уровне таблицы, вы можете объявить `UNIQUE` через несколько стобцов.

Ниже показано, как объявляется ограничение `UNIQUE` на уровне солбца:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table_name (
  ...,
  column_name TYPE UNIQUE,
  ...
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Или на уровне таблицы:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table_name (
  ...,
  UNIQUE(column_name)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ниже показано, как объявить ограничение для нескольких столбцов:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table_name (
  ...,
  UNIQUE(column_name1, column_name2, ...)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как только вы объявили `UNIQUE`, если будет вставка или обновление значения, которое уже существует, SQLite выдасть ошибку и прервет операцию.

## Примеры ограничения SQLite `UNIQUE`

Давайте приведем несколько примеров ограничения `UNIQUE`.

### Объявение ограничения для одной колонки

Ниже приведено выражение, создающее новую таблицу `contacts` с ограничением `UNIQUE` у столбца `email`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE contacts (
  contact_id INTEGER PRIMARY KEY,
  first_name TEXT,
  last_name TEXT,
  email TEXT NOT NULL UNIQUE
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Слудующее выражение вставляет новую строку в таблицу `contacts`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO contacts (first_name, last_name, email)
VALUES ('John', 'Doe', 'john.doe@gmail.com');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если вы попытаетесь вставить еще одну строку, с такими же полями, то получите ошибку.

### Объявление ограничения `UNIQUE` для нескольких колонок

Следующее выражение создает таблицу `shapes` с ограничением `UNIQUE` для столбцов `background_color` и `foreground_color`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE shapes (
  shape_id INTEGER PRIMARY KEY,
  background_color TEXT,
  foreground_color TEXT,
  UNIQUE (background_color, foreground_color)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Следующее выражение вставляет новую строку в таблицу `shapes`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO shapes (background_color, foreground_color)
VALUES ('red', 'green');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Это выражение работает, потому что нету дублей в обоих колонках:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO shapes (background_color, foreground_color)
VALUES ('red', 'blue');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Однако следующее выражение выдаст ошибку, поскольку имеет совподение в обоих колонках:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO shapes (background_color, foreground_color)
VALUES ('red', 'green');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Ограничение `UNIQUE` и `NULL`

SQLite рассматривает все значения `NULL` как разные, поэтому столбец с ограничением `UNIQUE` может иметь несколько значний `NULL`.

Следующее выражение создает новую таблицу под названием `lists`, чей столбец `email` имеет ограничение `UNIQUE`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE lists (
  list_id INTEGER PRIMARY KEY,
  email TEXT UNIQUE
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Следующее выражение вставляет несколько значений `NULL` в столбец `email`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO lists (email)
VALUES (NULL), (NULL);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Давайте выберем данные из таблицы:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT * FROM lists;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как видите, несмотря на ограничение уникальности, столбец `email` имеет несколько значений `NULL`. 

В этом руководстве вы узнали об ограничении `UNIQUE`, которое позволяет убедится в том, что значения столбца или группы столбцов не повторяются.

---------------------------------------

Предидущее руководство < [SQLite NOT NULL CONSTRAINT][prev]  
Следующее руководство > [SQLite CHECK CONSTRAINT][next]

[prev]: ../38_NotNullConstraint/translate.md
[next]: ../40_CheckConstraint/translate.md