# SQLite SUBQUERY ######################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-subquery/

## Обзор ##############################

В этом руководстве вы узнаете о подзапросах SQLite, которые используются для построения более читаемых и сложных запросов.

## Знакомство с подзапросами SQLite ###

Подзапрос - это выражение `SELECT` вложенное в другое выражение. Посмотрите следующее выражение:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT column_1
FROM table_1
WHERE column_1 = (
  SELECT column_1
  FROM table_2
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Слудующий запрос является внешним:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT column_1
FROM table_1
WHERE column_1 =
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

А следующий запрос - подзапрос:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(SELECT column_1 FROM table_2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

> Вы должны использовать пару скобок для обрамления подзапроса. Обратите внимание, что вы можете вложить подзапрос в другой подзапрос с определенной глубиной.

Как правило подзапрос возвращает одну строку в качестве атомарого значения, хотя он может возвращать несколько строк для сравнения в оператори `IN`.

Вы можете использовать подзапрос в предложениях `SELECT`, `FROM`, `WHERE` и `JOIN`.

## Примеры подзапросов SQLite #########

Мы будем использовать таблицы `tracks` и `albums` тестовой базы данных для демонстрации.

![tracks_albums][]

### 1) Подзапрос SQLite в предложении `WHERE`

Вы можете использовать простой подзапрос как условие поиска. Например, следующее выражение возвращает все треки из альбома с названием `Let There Be Rock`

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT 
  trackId,
  name,
  albumId
FROM tracks
WHERE albumId = (
  SELECT albumId
  FROM albums
  WHERE title = 'Let There Be Rock'
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Подзапрос возвращает id альбома с названием `'Let There Be Rock'`. Запрос использует оператор (=) для сравнения `albumId`, возвращенного подзапросом, с `albumId` из таблицы `tracks`.

Если подзапрос возвращает несколько значений, вы можете использовать оператор `IN` для проверки существования значения в списке значений.

Посмотрите следующие таблицы `employees` и `customers` той-же базы данных:

![customers_employees][]

Например, следующий запрос возвращает пользователей, чьи торговые представители находятся в Канаде.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT 
  customerId,
  firstname,
  lastname
FROM
  customers
WHERE
  supportrepId IN (
    SELECT employeeId
    FROM employees
    WHERE country = 'Canada'
  );
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Подзапрос возвращает список id сотрудников, которые находятся в Канаде. Внешний запрос использует оператор `IN` для поиска клиентов, чьи id торговx представителей находятся в списке.

### 2) Подзапросы SQLite в предложении `FROM`

Иногда вам нужно применить функцию аггрегации к столбцу несколько раз. Например, сначала, вы хотите просуммировать размер альбома, а затем, посчитать средний размер альбома. Вы можете использовать следующий запрос:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT AVG(SUM(bytes))
FROM tracks
GROUP BY albumId;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Этот запрос не работает.

Чтобы он заработал, вы можене использовать подзапрос в предложении `FROM`, как показано ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  AVG(album.size)
FROM
  (
    SELECT
      SUM(bytes) size
    FROM
      tracks
    GROUP BY 
      albumId
  ) AS album;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом случае, SQLite сначала выполнит подзапрос в предложении `FROM` и вернет результирующий набор. Затем, SQLite использует этот результат, как производную таблицу во внешнем запросе.

## Коррелированный подзапрос SQLite #########

Все подзапросы, которые вы видели до сих пор, могут быть запущены независимо. Другими словами, они не зависят от других запросов.

Коррелированный подзапрос - это подзапрос, который сипользует значения из других запросов. В отличии от обычных подзапросов, коррелированный не может быть выполнен отдельно.

Коррелированнные подзапросы не эффективны, потому что они выполняются для каждой строки внешнего запроса.

Следующий запрос использует коррелированный подзапрос для возврата альбомов, чей размер меньше чем `10mb`.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT 
  albumId,
  title
FROM
  albums
WHERE 10000000 > (
    SELECT SUM(bytes)
    FROM tracks
    WHERE tracks.albumId = albums.albumId
)
ORDER BY title;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как работает данный запрос:

- Для каждой строки выполняемого внешнего запроса, коррелированный подзапрос вычисляет размер альбома из таблицы треков, принадлежащей текущему альбому, используя функцию `SUM`.

- Предикат в предложении `WHERE` фильтрует альбомы, которые имеют размер больше чем `10mb`.

### Коррелированный подзапрос в предложении `SELECT`

Следующий запрос использует коррелированный подзапрос в предложении `SELECT` для возврата количества треков в альбоме.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT 
  albumId,
  title,
  (
    SELECT COUNT(trackId)
    FROM tracks
    WHERE tracks.albumId = albums.albumId
  ) tracks_count
FROM albums
ORDER BY tracks_count DESC;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом руководстве вы познакомились с подзапросами и увидели разные пути использования подзапроса в запросе для выбора данных из таблиц.

Предидущее руководство < [SQLite INTERSECT][prev]  
Следующее руководство > [SQLite EXISTS][next]

[prev]: ../21_Intersect/translate.md
[next]: ../23_Exists/translate.md

[tracks_albums]: ./tracks_albums.png
[customers_employees]: ./customers_employees.png