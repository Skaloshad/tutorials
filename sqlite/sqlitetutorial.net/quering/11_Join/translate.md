# SQLite JOIN ######################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-join/

## Обзор ##############################

В этом руководстве вы узнаете о различных видах объединений SQLite для запроса данных из двух и более таблиц.

Для демонстрации мы будем использовать таблицы `artists` и `albums` тестовой базы данных.

![atrist-albums][artistAlbums]

Артист может иметь ноль или несколько альбомов, в то время как альбом принадлежит одному артисту.

Для выбора данных из обоих таблиц `artists` и `albums` вы можете использовать выражения: `INNER JOIN`, `LEFT JOIN`, `JOIN` или `CROSS JOIN`. Каждый оператор объединения определяет как SQLite будет использовать данные для сопоставления строк одной таблицы, другой.

Обратите внимание, что SQLite напрямую не подднрживает `RIGHT JOIN` и `FULL OUTER JOIN`.

## SQLite INNER JOIN

Следующее выражение вернет названия альбомов и их имена артистов:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  title,
  name
FROM
  albums
INNER JOIN artists
  ON artists.artistId = albums.artistId;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом примере оператор `INNER JOIN` сопоставляет каждую строку из таблицы `albums` с каждой строкой из таблицы `artists`, основываясь на условии объединения (`artists.artistId = album.artistId`) указанного после ключегого слова `ON`.

Если условие объединения вычисляется как `true` (или `1`), столбцы строк обоих таблиц включаются в результирующий набор.

Этот запрос использует псевдонимы (`l` для таблицы `albums` и `r` для таблицы `artists`) для сокращения запроса:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  l.title,
  r.name
FROM
  albums l
INNER JOIN artists r ON
  r.artistId = l.artistId;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В случае, если имена столбцов объединяемых таблиц одинаковые, например, `artistId`, вы можете использовать синтаксис `USING`, как показано ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  title,
  name
FROM
  albums
INNER JOIN artists USING(artistId);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Предложение `USING(artistId)` эквивалентно предложению `ON artists.artistId = albums.artistId`.

## SQLite LEFT JOIN

Выражение, которое выбирает имена артистов и названия альбомов из таблиц `artists` и `albums` используя предложение `LEFT JOIN`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  name,
  title
FROM
  artists
LEFT JOIN albums ON
  artists.artistId = albums.artistId
ORDER BY name;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Предложение `LEFT JOIN` выбирает данные начиная с левой таблицы (`artists`) и сопоставляет строки с правой таблицей (`albums`) основываясь на условии объединения (`artists.artistId = album.artistId`).

Левое объединение возвращает все строки из таблицы `artists` (или левой таблицы) и сопоставляет строки из таблицы `albums` (или правой таблицы).

Если строка из левой таблицы не имеет соответствия строки из правой таблицы, SQLite включает столбцы строк из левой таблицы и `NULL` из столбцов строк правой таблицы.

По аналогии с предложением `INNER JOIN`, вы можете использовать синтаксис `USING` для условия объединения, как показано далее:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  name,
  title
FROM
  artists
LEFT JOIN albums USING (artistId)
ORDER BY 
  name;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если вы хотите найти артистов, которые не имеют какого-либо альбома, вы можете добавить предложение `WHERE`, как показано в следующем запросе:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  name,
  title
FROM
  artists
LEFT JOIN albums ON
  artists.artistId = albums.artistId
WHERE title IS NULL
ORDER BY name;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как правило этот тип запросов позволяет вам найти строки, которые доступны в левой таблице, но не имеют соответствующих строк в правой таблице.

Обратите внимание, что `LEFT JOIN` и `LEFT OUTER JOIN` являются синонимами.

## SQLite CROSS JOIN

Предложение `CROSS JOIN` создает декартово произведение строк объединяемых таблиц.

В отличии от `INNER JOIN` и `LEFT JOIN`, `CROSS JOIN` не имеет условия объединения. Вот базовый синтаксис предложения `CROSS JOIN`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT
  select_list
FROM table1
CROSS JOIN table2;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`CROSS JOIN` комбинирует каждую строку из первой таблицы (`table1`) с каждой строкой второй таблицы (`table2`) для формирования результирующего набора.

Если первая таблица имеет `N` строк, вторая таблица имеет `M` строк, конечный результат будет `NxM` строк.

На практике `CROSS JOIN` используется для комбинирования двух наборов данных для формирования исходного набора данных для дальнейшей обработки. Например, у вас есть список продуктов и месяцев, и вы хотите создать план, когда вы можете продать какие продукы.

Следующий скрипт создает таблицы `products` и `calendars`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE products(
  product text NOT NULL
);

INSERT INTO products(product)
VALUES ('P1'),('P2'),('P3');

CREATE TABLE calendars(
    y int NOT NULL,
    m int NOT NULL
)

INSERT INTO calendars(y, m)
VALUES
  (2019,1),
  (2019,2),
  (2019,3),
  (2019,4), 
  (2019,5),
  (2019,6),
  (2019,7),
  (2019,8), 
  (2019,9),
  (2019,10),
  (2019,11),
  (2019,12);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Этот запрос использует `CROSS JOIN` для комбинации продуктов и месяцев:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT *
FROM products
CROSS JOIN calendars;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом руководстве вы изучили разные типы объединений SQLite, которые позволяют выбирать данные из нескольких таблиц.

Предидущее руководство < [SQLite IS NULL][prev]  
Следующее руководство > [SQLite INNER JOIN][next]

[prev]: ../10_IsNull/translate.md
[next]: ../12_InnerJoin/translate.md

[artistAlbums]: ./artists_albums.png