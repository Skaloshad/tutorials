# SQLite AUTOINCREMENT #########################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-autoincrement/

## Обзор ##############################

В этом руководстве вы узнаете об аттрибуте столбца SQLite `AUTOINCREMENT` и когда его использовать в вашей таблице.

## Знакомство с SQLite `ROWID`

Всякий раз, когда вы создаете таблицу без указания опции `WITHOIT ROWID`, вы имеете неявный автоинкрементируемый столбец `rowid`. Колонка `rowid` хранит 64х разрядный целочисленный уникальный идентификатор строки таблицы.

Давайте посмотрим следующий пример.

Для начала, создадим новую таблицу под названием `people`, которая имеет два столбца: `first_name` и `last_name`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE people (
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Затем, вставим строку в таблцу `people` используя следующее выражение `INSERT`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO people (first_name, last_name)
VALUES ('John', 'Doe');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Затем, выберем данные из таблицы `people` используя следующее выражение `SELECT`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT 
  rowid,
  first_name,
  last_name
FROM
  people;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как вы можете видеть из вывода, SQLite неявно создал колонку `rowid` и автоматически присвоил целочисленное значение, когда вы вставили новую строку в таблицу.

> Обратите внимание, вы также можете обращатся к столбцу `rowid` используя алиасы: `_rowid_` и `oid`.

Когда вы создаете таблицу, которая имеет столбец `INTEGER PRIMARY KEY`, этот столбец является алиасом столбца `rowid`.

Следующее выражение удаляет таблицу и пересоздает ее. В этот раз мы добавим другой столбец `person_id`, который миеет тип `INTEGER` и ограничение `PRIMARY KEY`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DROP TABLE people;

CREATE TABLE people (
  person_id INTEGER PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом случае колонка `person_id` является колонкой `rowid`.

Как SQLite присваивает значения колонке `rowid`?

Когда вы не указываете значение `rowid` или используете значение `NULL`, когда вставляете новую строку, SQLite автоматически присваивает следующий номер, который является следующим наибольшим `rowid` в таблице. Значения `rowid` начинаются с `1`.

Максимальное значение `rowid` - `9,223,372,036,854,775,807`, что я вляется очень большим числом. Если ваши данные достигнут максимального значения и вы попытаетесь вставить новую строку, SQLite найдет неиспользуемый номер и присвоит его. Если SQLite не сможет найти какой-либо подходящий номер, то он выдаст ошибку `SQLITE_FULL`. В дополнении к этому, если вы удалите некоторые строки, и вставите новую строку, SQLite попытается переиспользовать `rowid` удаленных строк.

Давайте потестируем это.

Для начала вставим строку с максимальным значением в таблицу `people`.

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO people (person_id, first_name, last_name)
VALUES ( 9223372036854775807, 'Johnathan', 'Smith' );
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Затем, вставим строку без указания значения `person_id`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO people (first_name, last_name)
VALUES ('William', 'Gate');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как видно из примера, новая строка использует не занятый номер.

Рассмотрим другой пример.

Сначала, создадим новую таблицу под названием `t1`, с одной колонкой:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE t1 (c TEXT);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Затем, вставим несколько строк:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO t1 (v1) VALUES ('A');
INSERT INTO t1 (v1) VALUES ('B');
INSERT INTO t1 (v1) VALUES ('C');
INSERT INTO t1 (v1) VALUES ('D');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Попытаемя выбрать данные из таблицы:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT rowid, v1 FROM t1;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Далее, удалим все строки из `t1`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DELETE FROM t1;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Далее вставим еще строки:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO t1 (v1) VALUES ('E');
INSERT INTO t1 (v1) VALUES ('F');
INSERT INTO t1 (v1) VALUES ('G');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Выберем данные:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SELECT rowid, v1 FROM t1;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Вы можете видеть, что rowid переиспользует номера 1, 2 и 3.

## Аттрибут столбца SQLite `AUTOINCREMENT`

SQLite не рекомендует использовать аттрибут `AUTOINCREMENT` по следующим причинам:

- Ключевое слово `AUTOINCREMENT` требует дополнительного CPU, памяти, диского пространства, дискового времени и его нужно избегать, если без него можно обойтись. Как правило он не нужен.

Также, способ, которым SQLite присваивает значения `AUTOINCREMENT` слегка отличается от присваивания `rowid`.

Рассмотрим следующий пример.

Для начала удалим и пересоздадим таблицу `people`. В этот раз мы используем аттрибут `AUTOINCREMENT`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DROP TABLE people;

CREATE TABLE people (
  person_id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Далее, вставим строку, с максимальным значением `rowid`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO people (person_id, first_name, last_name)
VALUES (9223372036854775807, 'Johnathan', 'Smith');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Затем, вставим другую строку:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO people (first_name, last_name)
VALUES ('John', 'Smith');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этот раз SQLite выведет сообщение об ошибке, потому что колонка `person_id` не переипользует номера как колонка с `rowid`.

Когда нужно использовать аттрибут столбца `AUTOINCREMENT`?

Основной причиной использования аттрибута `AUTOINCREMNT` является предотвращение SQLite переиспользовать значения, которые не были использованы, или значения ранее удаленных строк.

Если вы не имеете таких требований, то использовать `AUTOINCREMENT` не нужно.

В этом руководстве вы узнали про аттрибут SQLite `AUTOINCREMENT`, как он работает, и какие пути присваивания ключа существуют.

---------------------------------------

Предидущее руководство < [SQLite CREATE TABLE][prev]  
Следующее руководство > [SQLite PRIMARY KEY][next]

[prev]: ../34_CreateTable/translate.md
[next]: ../36_PrimaryKey/translate.md