# SQLite PRIMARY KEY #########################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-primary-key/

## Обзор ##############################

В этом руководстве вы изучите, как использовать ограничение SQLite `PRIMARY KEY` для объявления первичного ключа таблицы.

## Знакомство с первичным ключем SQLite

Первичный ключ - это колонки или группа колонок, используемая для определения уникальности строк в таблице. Каждая таблица имеет только один первичный ключ.

SQLite позволяет определить первичный ключ двумя путями:

Первый - если первичный ключ имеет только один столбец, используется ограничение столбца `PRIMARY KEY`, как показано ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table_name (
  column_1 INTEGER NOT NULL PRIMARY KEY,
  ...
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Второй - когда первичный ключ состоит из двух и более столбцов, использется ограничение таблицы `PRIMARY KEY`, как показано ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table_name (
  column_1 INTEGER NOT NULL,
  column_2 INTEGER NOT NULL,
  ...
  PRIMARY KEY (column_1, column_2, ...)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В страндарте SQL первичный ключ не должен иметь значений `NULL`. Это означает, что колонка первичного ключа имеет неявное ограничение `NOT NULL`.

Однако, чтобы сделать SQLite совместимым с более ранними версиями, он позволяет хранить в столбце первичного ключа значения `NULL`.

## Таблица с первичным ключем и rowid

Когда вы создаете таблицу без указания опции `WITHOUT ROWID`, SQLite добавляет скрытый столбец под названием `rowid`, который хранит 64х бытный номер. Столбец `rowid` это ключ, который определяет уникальность строки в таблице. Таблицы, которые имеют столбец `rowid` называются таблицами `rowid`.

Если таблица имеет первичный ключ, состоящий из одного столбца, и колонка объявлена как `INTEGER`, тогда колонка первичного ключа является алиасом колонки `rowid`.

> Обратите внимание, что, если вы присвоете колонке первичного ключа другой тип числа, например `BIGINT` и `USDIGNED INT`, эта колонка не будет являтся алиасом колонки `rowid`.

Из-за того, что таблица `rowid` организует данные как Б-дерево, запросы и сортировка данных происходит очень быстро. Это быстрее чем использовать первичный ключ, который не является `rowid`.

> Другим важным замечанием будет то, что если вы объявите колонку типа `INTEGER` и предложением `PRIMARY KEY DESC`, эта колонка также не будет являться алиасом колонки `rowid`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table (
  pk INTEGER PRIMARY KEY DESC,
  ...
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Примеры создания первичного ключа SQLite

Следующее выражение создает таблицу под названием `countries` которая имеет столбец первичного ключа `country_id`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE countries (
  country_id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Из-за того, что первичный ключ таблицы `countries` имеет только один стобец, мы указываем первичный ключ используя ограничение столбца `PRIMARY KEY`.

Также возможно указать ограничение колонки первичного ключа используя пограничение таблицы, как показано ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE languages (
  language_id INTEGER,
  name TEXT NOT NULL,
  PRIMARY KEY (language_id)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Однака, для описания первичного колюча, который имеет два и более столбца, вы должны использовать только ограничения таблицы.

Следующее выражение создает таблицу `country_languages` чей первичный ключ состоит из двух столбцов:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE country_languages (
  country_id INTEGER NOT NULL,
  language_id INTEGER NOT NULL,
  PRIMARY KEY (country_id, language_id),
  FOREIGN KEY (country_id) REFERENCES countries (country_id)
    ON DELETE CASCADE
    ON UPDATE NO ACTION,
  FOREIGN KEY (language_id) REFERENCES languages (language_id)
    ON DELETE CASCADE
    ON UPDATE NO ACTION
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Пример добавления первичного ключа SQLite

В отличае от других СУДП, таких как MySQL и PostgreSQL, вы не можете использовать выражение `ALTER TABLE` для добаления первичного ключа к существующей таблице.

Вы должны следовать следующим шагам чтобы обойти ограничение:

1. Выключите проверку внешнего колюча.
2. Переименуйте таблицу на другое название (old_table)
3. Создайте новую таблицу с такой же структурой и нужным названием.
4. Скопируйте данные из старой таблици в новую.
5. Включите проверку внешнего ключа.

Посмотрите следующее выражение:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRAGMA foreign_keys = off;

BEGIN TRANSACTION;

ALTER TABLE table RENAME TO old_table;

CREATE TABLE table ( ... );

INSERT INTO table SELECT * FROM old_table;

COMMIT;

PRAGMA foreign_keys = on;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`BEGIN TRANSACTION` начнет новую транзакцию. Ето гарантирует, что все подзапросы будут выполнены успешно или ничего не будет выполнено.

Выражение `COMMIT` сохранит все изменений.

Давайте создадим таблицу `cities` буз первичного коюча:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE cities (
  id INTEGER NOT NULL,
  name TEXT NOT NULL
);

INSERT INTO cities (id, name)
VALUES (1, 'San Jose');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для добавления первичного колюча таблице `sities` следуйте следующим шагам:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRAGMA foreign_keys = off;

BEGIN TRANSACTION;

ALTER TABLE cities RENAME TO old_cities;

CREATE TABLE cities (
  id INTEGER NOT NULL PRIMARY KEY,
  name TEXT NOT NULL
);

INSERT INTO cities 
SELECT * FROM old_cities;

DROP TABLE old_sities;

COMMIT;

PRAGMA foreign_keys = on;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если вы используете SQLite GUI, вы можете использовать следующее выражение для отображения информации по таблице:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRAGMA table_info([cities]);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом руководстве вы изучили ограничение SQLite `PRIMAEY KEY` определяющее первичный ключ для таблицы.

---------------------------------------

Предидущее руководство < [SQLite AUTOINCREMENT][prev]  
Следующее руководство > [SQLite FOREIGN KEY][next]

[prev]: ../35_Autoincrement/translate.md
[next]: ../37_ForeignKey/translate.md