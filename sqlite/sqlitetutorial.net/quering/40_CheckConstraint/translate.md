# SQLite CHECK CONSTRAINT #########################

[Файл с запросами][querys]   
[Оригинальная статья][origin]

[querys]: ./querys.sql
[origin]: https://www.sqlitetutorial.net/sqlite-check-constraint/

## Обзор ##############################

В этом руководстве вы изучите, как использовать ограничение `CHECK` для проверки значений перед их вставкой или обновлением.

## Знакомство с ограничением SQLite `CHECK`

Ограничение SQLite `CHECK` позволяет вам задать выражение для проверки значений которые вставляются или обновляются в стобце.

Если значение не подподает под критерии описанные в выражении, SQLite выдаст предупреждение о нарушении ограничения и отменит выражение.

Ограничение `CHECK` позволяет вам определить дополнительные проверки целостности данных кроме `UNIQUE` и `NOT NULL`, конкртетно под ваше приложение.

SQLite позволяет определить ограничение как на уровне столбца, так и на уровне таблицы.

Следующее выражение показвает как объявляется ограничение `CHECK` на уровне столбца:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table_name (
  ...,
  column_name DATA_TYPE CHECK(expression),
  ...
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

И следующее выражение иллюстрирует, как объявить ограничение `CHECK` на уровне таблицы:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE table_name (
  ...,
  CHECK(expression)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом синтаксисе, при вставке новой строки или обновлении уже имеющейся строки, выражение относящееся к каждому ограничению `CHECK` выполняется и возвращает числовое значение `0` или `1`.

Если рузультат равен нулю, то возникает нарушение ограничения. Если результат не ноль или `NULL`, то это означает, что нарушения ограничения не последовало.

> Обратите внимание, что выражение ограничения `CHECK` не может быть подзапросом.

## Примеры ограничения SQLite `CHECK`

Давайте возмем несколько примеров использования ограничения `CHECK`.

### Пример использования ограничения `CHECK` на уровне столбца

Следующее выражение создает новую таблицу под названием `contacts`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE contacts (
  contact_id INTEGER PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT,
  phone TEXT NOT NULL CHECK (length(phone) >= 10)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В таблице `contacts` столбец `phone` имеет ограничение `CHECK`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CHECK (length(phone) >= 10)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Это ограничение `CHEKE` гарантирует, что значение столбца `phone` должно быть как минимум 10 символов.

Если вы попытаетесь выполнить следующее выражение, вы получите ошибку нарушения ограничения:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO contacts (first_name, last_name, phone)
VALUES ('John', 'Doe', '408123456');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Причина, по которой это произошло в том, что телефон, который вы пытались вставить содержит всего 9 символов, хотя требуется как минимум 10.

Следующее выражение должно выполнится, поскольку значение столбца `phone` имеет 13 символов, что удовлетворяет выражению ограничения `CHECK`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO contacts (first_name, last_name, phone)
VALUES ('John', 'Doe', '(408)-123-456');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Пример использования ограничения SQLite `CHECK` на уровне таблицы

Следующее выражение создает новую таблицу под названием `products`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE products (
  product_id INTEGER PRIMARY KEY,
  product_name TEXT NOT NULL,
  list_price DECIMAL (10, 2) NOT NULL,
  discount DECIMAL (10, 2) NOT NULL DEFAULT 0,
  CHECK (list_price >= discount AND discount >= 0 AND list_price >= 0)
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В этом выражении ограничение `CHECK` объявлено на уровне таблицы:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CHECK (list_price >= discount AND discount >= 0 AND list_price >= 0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ограничение `CHECK` гарантирует, что цена всегда будет больше или равна скидке и что скидка и цена вместе будет больше нуля.

Следующее выражение нарушает ограничение `CHECK`, так как скидка больше чем цена:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO products (product_name, list_price, discount)
VALUES ('New Product', 900, 1000);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Следующее выражение также нарушит ограничение `CHECK`, так как скидка отрицательа:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO products (product_name, list_price, discount)
VALUES ('New Product', 1000, -10);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Добавление ограничения SQLite `CHECK` в существующую таблицу

Начиная с версии 3.25.2, SQLite не поддерживает добавление ограничения `CHECK` в существующую таблицу.

Однако, вы можете следовать этим шагам:

1. Создайте новую таблицу с точно такой же структурой, как и у таблицы в которую вы хотите добавить ограничение. Новая таблица уже должна включать ограничение `CHECK`:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CREATE TABLE new_table (
  [...],
  CHECK ([...])
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для получения структуры старой таблицы, вы можете обратиться к комманде `.schema`. Да более подробной информации посмотрите руководство по [описанию таблицы][describe].

2. Скопируйте данные из старой таблицы в новую:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INSERT INTO new_table SELECT * FROM old_table;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3. Удалите старую таблицу:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DROP TABLE old_table;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4. Переименуйте новую таблицу в назание старой:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ALTER TABLE new_table RENAME TO old_table;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для того, чтобы гарантировать выполнение всех выражений, оберните их в транзакцию, как показано ниже:

~~~ SQL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BEGIN;

CREATE TABLE new_table (
  [...],
  CHECK ([...])
);

INSERT INTO new_table SELECT * FROM old_table;

DROP TABLE old_table;

ALTER TABLE new_table RENAME TO old_table;

COMMIT;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---------------------------------------

Предидущее руководство < [SQLite UNIQUE CONSTRAINT][prev]  
Следующее руководство > [SQLite ALTER TABLE][next]

[prev]: ../39_UniqueConstraint/translate.md
[next]: ../41_AlterTable/translate.md

[describe]: https://www.sqlitetutorial.net/sqlite-describe-table/